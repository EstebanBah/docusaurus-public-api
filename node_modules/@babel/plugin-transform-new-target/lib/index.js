"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
<<<<<<< Updated upstream
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
=======

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _core = require("@babel/core");

>>>>>>> Stashed changes
var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: "transform-new-target",
    visitor: {
      MetaProperty(path) {
        const meta = path.get("meta");
        const property = path.get("property");
        const {
          scope
        } = path;
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
        if (meta.isIdentifier({
          name: "new"
        }) && property.isIdentifier({
          name: "target"
        })) {
          const func = path.findParent(path => {
            if (path.isClass()) return true;
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
            if (path.isFunction() && !path.isArrowFunctionExpression()) {
              if (path.isClassMethod({
                kind: "constructor"
              })) {
                return false;
              }
<<<<<<< Updated upstream
              return true;
            }
            return false;
          });
          if (!func) {
            throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
          }
          const {
            node
          } = func;
=======

              return true;
            }

            return false;
          });

          if (!func) {
            throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
          }

          const {
            node
          } = func;

>>>>>>> Stashed changes
          if (_core.types.isMethod(node)) {
            path.replaceWith(scope.buildUndefinedNode());
            return;
          }
<<<<<<< Updated upstream
          const constructor = _core.types.memberExpression(_core.types.thisExpression(), _core.types.identifier("constructor"));
=======

          const constructor = _core.types.memberExpression(_core.types.thisExpression(), _core.types.identifier("constructor"));

>>>>>>> Stashed changes
          if (func.isClass()) {
            path.replaceWith(constructor);
            return;
          }
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
          if (!node.id) {
            node.id = scope.generateUidIdentifier("target");
          } else {
            let scope = path.scope;
            const name = node.id.name;
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
            while (scope !== func.parentPath.scope) {
              if (scope.hasOwnBinding(name) && !scope.bindingIdentifierEquals(name, node.id)) {
                scope.rename(name);
              }
<<<<<<< Updated upstream
              scope = scope.parent;
            }
          }
          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("instanceof", _core.types.thisExpression(), _core.types.cloneNode(node.id)), constructor, scope.buildUndefinedNode()));
        }
      }
    }
  };
});
exports.default = _default;

//# sourceMappingURL=index.js.map
=======

              scope = scope.parent;
            }
          }

          path.replaceWith(_core.types.conditionalExpression(_core.types.binaryExpression("instanceof", _core.types.thisExpression(), _core.types.cloneNode(node.id)), constructor, scope.buildUndefinedNode()));
        }
      }

    }
  };
});

exports.default = _default;
>>>>>>> Stashed changes
